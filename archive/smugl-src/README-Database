SMUGL Game Database
-------------------
$Id: README-Database,v 1.2 1997/04/25 01:13:13 oliver Exp $

This document describes the structures, files and operating mechanisms
that SMUGL uses to present, operate and manage its "game database".

SMUGL compilation produces a number of tables which are grouped
as below:

 . "vocab" - a dictionary of all the "user defined" words
 . "umsgs" - of all of the user defined messages or text strings
 . "language" - the game instructions
 . "relations" - player ranks, synonyms, mobile personnas
 . "components" - rooms and objects

Below is a more detailed description of each category, what it
contains, and aspects of implementation.


Vocab
-----

The game treats the vocabulary as an array of strings; the text, or
string space, is actually stored as a straight forward sequence of
back-to-back, null-terminated ascii strings). As the game accumulates
words, it builds a straight-forward index, such that entry 53 in the
index is a pointer to the 53rd string in the 'string space'. The numeric
position of a word within the vocab index is known as its Vocab ID
(typedef'd as vocid_t).

To convert a vocid_t index number into a string, use the libsmugl
function 'char *word(vocid_t wordno), e.g. to print word 53:

  printf("word 53 = %s\n", word(53));

The vocab table can grow quite large. As it does so, doing a linear
search across the table can become quite cumbersome. To get around
this, a simple hashing mechanism is employed. This performs a quick
mathematical operation on your keyword producing an unsigned long
value. This is used as an index to a "slot" within the hash, under
which your keyword will be found, if it is in the current index.

Instead of having to search through, maybe, 600+ words, searches can
be concluded after only 5 or 6 matches, and a neglible mathematical
operation, comparable to a single match. This makes vocab lookups
*very* quick.

libsmugl provides a function for doing these forward lookups,
'vocid_t is_word(const char *s)', which returns -1 if the word is
not in the index, otherwise it returns a standard 'vocid_t', thus

  if ((wordid = is_word("jump")) == -1)
      printf("I don't know the word 'jump'\n");
  else printf("I know 'jump', it's word#%d in my index\n", wordid);

The various vocab tables are implemented as arrays of longs, which
the compiler grows automatically. At this point in time it is not
possible for the game front end to alter these vocab table once the
game is under way.


Umsgs
-----

Originally, AMUL made a mess of user-defined text strings. They were
all over the place. SMUGL, however, considers all user-defined text
strings equal (although seperate from the vocabulary strings). This
includes room descriptions, system-responses, object descriptions
and strings defined in the language tables.

The umsg table comes in two parts; another, straight-forward, ascii,
null-terminated string table, and an index. The index contains offsets
to the positions of each message within the 'string space', and consists
of longs (on loading, SMUGL quietly converts all of these to pointers
to cut down on de-referencing overheads).

Again, a typedef is supplied for message-number indexes: msgno_t

NOTE: The "system messages", that is, user-defined text for standard
responses (such as "Press Return"), are stored at the 'top' of string
space, so SysMsg number 0 is the first string in string space.

In the 'smugl' environment, string space is indicated by
  data->msgbase
and the function 'const char *textproc.C::message(int msgno_t)' can
be used to convert a msgno_t into a text pointer, e.g.
  printf("system message 5 = %s\n", message(5));


Language
--------

The language section consists of a number of files, combining the
Travel Table and the Language Table (i.e. LANG.txt and TRAVEL.txt).
The files are several layers deep.

1. the Travel Table (TT):

Each room has a pointer to it's section of the TT, which is an
array of _TT_ENT entries. The table entries are accessed by
a combination of room and verb. By scanning through the entries
in the given rooms section for matching 'verb' indexes, you can
determine which entries should be further evaluated. Each entry
contains both the condition and action required for evaluation or
processing.

2. the Language Table (LT):

By far the more complex: The LT is initially indexed by verb,
where each _VERB_STRUCT has a pointer to it's section in the
next layer. The second layer, an array of one-or-more _SLOTTAB
entries, specifies the rules for matching against the rest of
the 'player input' through the 'wtype' (word type, e.g. noun,
adjective, player, etc) and 'slot' (specific values, e.g.
door, me, 5, <50, etc) fields.

The _SLOTTAB structures further index the groups of _VBTAB
entries (which are similar to the TT's _TT_ENT) which should
be evaluated for player input that matches the wtype/slot
values.

Both _TT_ENT and _VBTAB structures contain 'pptr' pointers,
which point to a final table, containing the argument values
for the condition/action combinations in either structure.

XXX: Explanation of funcionality required


Relations
---------

The relations table is a sort of 'miscellaneous' category, where tributary
or control data goes. It contains:

. Aliases or Synonyms
 Quite simply associates words together or specifies that one word
 should be considered as meaning another, e.g. "take" is an alias for "get"

. Ranks
 Defines the available player ranks, which is an ambiguous extension of
 the player object.

. Mobile Personnas
 MPs define the categories of personnas available, by specifying, for
 instance, an MP called "dog" which has a given set of characteristics.
 Creating a personna does not create a mobile. Instead, MPs are reusable,
 in that one personna can be assigned to multiple objects, which will
 then all operate independently, but with the same characteristics (e.g.
 rate of movement, likelihood to move, etc).

XXX: More detail I think


Components
----------

The Components category consists of the more tangible elements of the
game; rooms, players and objects.

AMUL treated all of these (infact all) objects independently. It's my
aim to have SMUGL have a common base for all objects, the BASIC_OBJ
structure.

XXX: Definitely need more here ;-)
